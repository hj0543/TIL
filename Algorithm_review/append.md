## 1) `append()` : 리스트에 “원소 1개”를 끝에 추가

### 기본 형태

```python
리스트.append(값)
```

### 동작 원리

* 리스트의 **맨 뒤**에 새 요소를 **1개** 붙입니다.
* **원본 리스트가 직접 바뀝니다(제자리 수정, in-place)**.
* 반환값은 `None`입니다. (매우 중요)

```python
a = [1, 2]
r = a.append(3)

print(a)  # [1, 2, 3]
print(r)  # None
```

#### 왜 반환값이 None인가?

* `append`는 “리스트를 수정하는 메서드”라서, 수정 결과를 새 리스트로 돌려주지 않습니다.
* 그래서 `a = a.append(3)` 같은 코드는 **a가 None이 되어버리는 실수**를 유발합니다.

---

### `append`와 `extend` 차이 (자주 헷갈림)

#### `append`: 통째로 “하나” 넣음

```python
a = [1, 2]
a.append([3, 4])
print(a)  # [1, 2, [3, 4]]
```

* 리스트 `[3,4]` 자체가 **원소 1개로 들어감**.

#### `extend`: 여러 개를 “풀어서” 넣음

```python
a = [1, 2]
a.extend([3, 4])
print(a)  # [1, 2, 3, 4]
```

* `[3,4]`의 요소들이 **각각 따로 추가**됨.

---

### 10871 풀이에서 `append(str(A[i]))`를 쓰는 이유

```python
ans.append(str(A[i]))
```

* 나중에 `" ".join(ans)`를 하려면 `ans` 내부가 **문자열 리스트**여야 합니다.
* `join`은 정수 리스트를 바로 합칠 수 없기 때문에 `str()`로 변환해 저장합니다.

## 2) 자주 나오는 실수 모음

### (1) `append` 결과를 변수에 다시 담기

```python
ans = ans.append("3")  # ans가 None이 됨 (오류 유발)
```

### (2) append와 extend 헷갈림

```python
ans.append([1,2])  # 원소가 리스트로 들어감
```

원한 게 `[1,2]`를 “펼쳐서” 넣는 거면 `extend`가 맞습니다.