
# [Algorithm] 재귀(Recursion)로 구현하는 DFS (깊이 우선 탐색)

## 1. DFS (Depth-First Search)란?

* **개념:** 그래프나 트리에서 시작 노드에서 다음 분기(Branch)로 넘어가기 전에, 해당 분기를 완벽하게(깊게) 탐색하는 방법.
* **핵심:** "한 우물만 끝까지 판다." (더 이상 갈 곳이 없으면 이전 갈림길로 돌아옴 → **Backtracking**)
* **구현 방식:** **재귀 함수(Recursion)** 또는 스택(Stack) 자료구조 사용.

## 2. 문제 해결 전략 (Flow)

### ① 데이터 저장: 인접 리스트 (Adjacency List)

* 행렬(Matrix)보다 메모리를 효율적으로 사용함.
* **Tip:** 정점 번호가 1번부터 시작하는 경우가 많으므로, 리스트 크기를 `V + 1`로 잡아 인덱스 0번을 버리고 1번 인덱스부터 사용하는 것이 직관적임.
```python
# V: 정점 개수
adj = [[] for _ in range(V + 1)]

```



### ② 방문 체크: Visited 배열

* 재귀 함수는 무한 루프에 빠질 위험이 있으므로, **이미 방문한 노드는 다시 가지 않도록** 기록이 필수.
* `visited = [False] * (V + 1)`

### ③ 재귀 로직 (3단계 공식)

1. **입장(Entry):** 현재 노드 방문 처리 (`visited[v] = True`) 및 작업 수행(출력 등).
2. **탐색(Look):** 현재 노드와 연결된 인접 노드(`graph[v]`)들을 순회.
3. **이동(Go):** 방문하지 않은 이웃이 있다면 재귀 호출 (`dfs(next_node)`).

## 3. 코드 구현 (Python)

```python
import sys
# 재귀 깊이 제한 해제 (Python 기본 1000 -> 1,000,000)
sys.setrecursionlimit(10**6)

def dfs(v):
    # 1. 방문 처리 (입장 도장)
    visited[v] = True
    print(v, end=' ')
    
    # 2. 인접 노드 탐색
    for w in graph[v]:
        # 3. 방문하지 않은 곳이라면 깊게 들어감(재귀)
        if not visited[w]:
            dfs(w)

# --- 입력 처리 ---
V, E = map(int, input().split())  # V: 정점, E: 간선
graph = [[] for _ in range(V + 1)] # 인접 리스트 (0번 인덱스 미사용)
visited = [False] * (V + 1)        # 방문 체크 리스트

# 간선 정보 입력 (일렬로 들어오는 경우)
# 예: 1 2 1 3 2 4 ...
temp = list(map(int, input().split()))

for i in range(E):
    s, e = temp[2*i], temp[2*i+1] # 두 개씩 끊어서 읽기
    graph[s].append(e)
    graph[e].append(s) # 양방향 연결!

# --- 실행 ---
print("DFS 탐색 경로:")
dfs(1) # 1번 정점부터 시작

```
### 코드 구조 분석

#### ① 그래프 데이터 저장 (인접 리스트 생성)

```python
v, E = map(int, input().split()) # 정점 개수(V), 간선 개수(E)
G_lst = [[] for _ in range(v + 1)] # 인덱스 0은 비워두고 1~V번 사용

```

* **`v + 1`을 하는 이유:** 문제에서 정점 번호가 보통 1부터 시작하기 때문입니다. 리스트는 0번부터 시작하므로, 헷갈리지 않게 **0번 인덱스는 버리고 1번 인덱스를 1번 정점으로 매칭**시키는 것이 국룰(관례)입니다.
* **초기 상태:** `[ [], [], [], ... ]` (빈 방들을 만들어 둠)

#### ② 간선 연결 (양방향 처리)

```python
for i in range(E):
    s, e = temp[2*i], temp[2*i+1] # (시작, 끝) 쌍을 가져옴
    G_lst[s].append(e) # s에서 e로 갈 수 있음
    G_lst[e].append(s) # e에서 s로도 갈 수 있음 (양방향)

```

* **`temp` 리스트 처리:** 입력이 `1 2 1 3...` 처럼 한 줄로 들어올 때, 2칸씩 점프(`2*i`, `2*i+1`)하며 읽어오는 테크닉입니다.
* **양방향 매핑:** `G_lst[s].append(e)`만 하면 **단방향(화살표)** 그래프가 됩니다. "길은 양쪽으로 뚫려있다"는 전제이므로 반대쪽(`e -> s`)도 반드시 추가해야 합니다.

#### ③ 재귀 함수 (DFS 로직)

```python
def dfs(G_lst, v):
    visited[v] = True      # 1. 입장하자마자 "나 여기 왔음" 도장 찍기
    print(v, end=' ')      # 2. 할 일 하기 (출력)
    
    for w in G_lst[v]:     # 3. 내 친구(인접 노드)들 확인
        if visited[w] != True:  # 4. 아직 안 가본 친구면?
            dfs(G_lst, w)       # 5. 그 친구네 집으로 이동 (재귀 호출)

```

* **`visited` 체크 위치:** 재귀 함수 **진입 직후**에 하는 것이 가장 깔끔합니다. (호출하기 전에 체크하는 방식도 있지만, 진입 후 체크가 실수할 확률이 적습니다.)
* **For문의 역할:** 현재 위치 `v`에서 갈 수 있는 모든 곳(`w`)을 둘러봅니다.
* **재귀의 끝:** `visited[w]`가 모두 `True`이거나, 연결된 `w`가 더 이상 없으면 `for`문이 끝나고 함수가 종료(return)되어 **이전 노드로 되돌아갑니다(Backtracking).**


## 4. 실행 과정 추적 (Trace)

> **입력 예시:** 정점 7개, 연결 `1-2, 1-3, 2-4, 2-5, 4-6, 5-6, 6-7, 3-7`

1. **`dfs(1)`**: 1번 방문. 인접한 `2`로 이동.
2. **`dfs(2)`**: 2번 방문. 인접한 `4`로 이동.
3. **`dfs(4)`**: 4번 방문. 인접한 `6`으로 이동.
4. **`dfs(6)`**: 6번 방문. 인접한 `5`로 이동.
5. **`dfs(5)`**: 5번 방문. 갈 곳 없음(2, 6 모두 방문함) → **종료(Return)**
6. **`dfs(6)` 복귀**: 5번 끝남. 다음 인접 `7`로 이동.
7. **`dfs(7)`**: 7번 방문. 인접한 `3`으로 이동.
8. **`dfs(3)`**: 3번 방문. 갈 곳 없음 → **종료**
9. 이후 역순으로 스택이 비워지며 전체 종료.

* **입력 연결:** `(1-2), (1-3), (2-4), (2-5), (4-6), (5-6), (6-7), (3-7)`
* **G_lst 상태 (정렬되었다고 가정 시):**
* 1: [2, 3]
* 2: [1, 4, 5]
* 4: [2, 6]
* 5: [2, 6]
* 6: [4, 5, 7]
* 7: [6, 3]
* 3: [1, 7]



**[실제 탐색 순서: 1 → 2 → 4 → 6 → 5 → 7 → 3]**

1. **`dfs(1)` 호출:** 1번 방문. 인접한 [2, 3] 중 **2**로 이동.
2. **`dfs(2)` 호출:** 2번 방문. 인접한 [1, 4, 5] 중 1은 갔으니 **4**로 이동.
3. **`dfs(4)` 호출:** 4번 방문. 인접한 [2, 6] 중 2는 갔으니 **6**으로 이동.
4. **`dfs(6)` 호출:** 6번 방문. 인접한 [4, 5, 7] 중 4는 갔으니 **5**로 이동.
5. **`dfs(5)` 호출:** 5번 방문. 인접한 [2, 6] 확인.
* 2번? 이미 방문함.
* 6번? 이미 방문함.
* 갈 곳 없음 → **5번 함수 종료(Return)** → 6번으로 복귀.


6. **`dfs(6)` 복귀 후:** 아까 5번까지 봤으니, 다음 **7**로 이동.
7. **`dfs(7)` 호출:** 7번 방문. 인접한 [6, 3] 중 6은 갔으니 **3**으로 이동.
8. **`dfs(3)` 호출:** 3번 방문. 인접한 [1, 7] 확인.
* 1번? 방문함.
* 7번? 방문함.
* 갈 곳 없음 → **3번 함수 종료** → 7번으로 복귀.

**결과:** `1 -> 2 -> 4 -> 6 -> 5 -> 7 -> 3`

## 5. 배운 점 & 주의할 점 (Retrospective)

1. **양방향 vs 단방향:** 문제에서 "연결되어 있다"라고 하면 보통 양방향이다. 입력받을 때 `graph[s].append(e)`와 `graph[e].append(s)`를 둘 다 해주는 것을 잊지 말자.
2. **인덱스 매핑:** 입력값 파싱 시 `temp` 리스트에서 `2*i`, `2*i+1` 처럼 인덱스를 조절하여 `(start, end)` 쌍을 가져오는 테크닉이 유용했다.
3. **시스템 스택:** 재귀를 쓰면 컴퓨터 내부의 스택(Stack) 메모리를 사용한다. 따라서 별도의 스택 자료구조를 `push/pop` 하는 코드를 짤 필요 없이 코드가 간결해진다.
4. **RecursionError:** 파이썬은 재귀 깊이 제한이 타이트하므로, 노드가 많은 그래프 문제에서는 `sys.setrecursionlimit()` 설정이 필수다.

