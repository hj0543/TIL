
# [Algorithm] 큐(Queue)로 구현하는 BFS (너비 우선 탐색)

## 1. BFS (Breadth-First Search)란?

* **개념:** 시작 노드에서 가까운 노드들을 먼저 다 방문하고, 그 다음 멀리 있는 노드들을 탐색하는 방법.
* **핵심:** **"인맥 넓히기."** (내 바로 옆 친구들을 다 만난 뒤에, 그 친구들의 친구들을 만남.)
* **특징:** 두 노드 사이의 **최단 경로**를 찾을 때 사용됩니다.
* **구현 방식:** **큐(Queue)** 자료구조를 사용합니다. (FIFO: First-In, First-Out)

## 2. 문제 해결 전략 (Flow)

### ① 데이터 저장: 인접 리스트

DFS와 동일하게 인접 리스트를 사용하여 간선 정보를 저장합니다.

### ② 방문 체크: Visited 배열

BFS에서도 무한 루프 방지를 위해 방문 체크가 필수입니다. 다만, **큐에 넣는 순간(예약)** 바로 방문 체크를 하는 것이 중복 방문을 막는 핵심 팁입니다.

### ③ 큐 로직 (3단계 공식)

1. **시작(Push):** 시작 노드를 큐에 넣고 방문 처리한다.
2. **반복(Pop & Look):** 큐가 빌 때까지 다음을 반복한다.
* 큐에서 노드 하나를 꺼낸다 (`popleft`).
* 꺼낸 노드의 인접 노드들을 확인한다.


3. **확장(EnQueue):** 아직 방문하지 않은 인접 노드가 있다면 **큐에 넣고 즉시 방문 처리**를 한다.

---

## 3. 코드 구현 (Python)

```python
from collections import deque

# ----------------------------------------
# 1. BFS 함수 정의 (핵심 로직)
# ----------------------------------------
def bfs(graph, start_node):
    """
    graph: 인접 리스트 (그래프 정보)
    start_node: 탐색을 시작할 정점 번호
    """
    
    # [방문 체크표 만들기]
    # 그래프의 크기(len(graph))만큼 False로 채운 리스트 생성
    # 예: 정점이 5개면 인덱스 0~5까지 총 6칸 생성 (0번은 안 씀)
    visited = [False] * len(graph)
    
    # [큐 생성 및 시작점 넣기]
    # deque를 써야 데이터 입출력 속도가 빠름 (O(1))
    queue = deque([start_node])
    
    # [시작점 방문 처리]
    # 큐에 넣는 순간 "나 여기 갈 거야/왔어"라고 체크해야 중복 방문 안 함
    visited[start_node] = True
    
    # [탐색 시작]
    # 큐가 비어있지 않다면(할 일이 남아있다면) 계속 반복
    while queue:
        # 1. 큐의 가장 왼쪽(먼저 들어온 것)에서 정점 하나 꺼냄
        current_node = queue.popleft()
        
        # 2. 현재 방문한 노드 출력 (여기서 필요한 로직 수행)
        print(current_node, end=' ')
        
        # 3. 현재 노드와 연결된 친구들(인접 노드)을 하나씩 확인
        for neighbor in graph[current_node]:
            # 4. 그 친구가 아직 방문하지 않은 곳이라면?
            if not visited[neighbor]:
                queue.append(neighbor)  # 큐에 줄 세우기 (예약)
                visited[neighbor] = True # 방문 도장 쾅! (예약 확정)

# ----------------------------------------
# 2. 입력 및 데이터 처리 부분
# ----------------------------------------

# 입력 예시: 
# 5 5         <- 정점 개수(V), 간선 개수(E)
# 5 4 5 2 1 2 3 4 3 1  <- 연결 정보 (5-4, 5-2, 1-2, 3-4, 3-1)

# V(정점), E(간선) 입력받기
V, E = map(int, input().split())

# [인접 리스트 초기화]
# 정점 번호가 1번부터 시작하므로, 인덱스 계산 편하게 V+1 크기로 만듦
# graph = [[], [], [], [], [], ...] 
graph = [[] for _ in range(V + 1)]

# [간선 정보 입력받기]
# 한 줄로 쭉 들어오는 입력을 리스트로 변환
temp = list(map(int, input().split()))

# 간선 개수(E)만큼 반복하며 연결 정보 저장
for i in range(E):
    # 입력 리스트에서 2개씩 짝지어 가져오기 (시작점, 도착점)
    s = temp[2 * i]     # 0, 2, 4... 짝수 인덱스
    e = temp[2 * i + 1] # 1, 3, 5... 홀수 인덱스
    
    # 양방향 그래프이므로 양쪽에 서로를 추가
    graph[s].append(e)
    graph[e].append(s)

# [정렬 (옵션)]
# "번호가 작은 정점부터 방문한다"는 조건이 있을 때 필수
# 예: 1번과 연결된 게 3, 2라면 -> 2, 3 순서로 방문하도록 정렬
for i in range(1, V + 1):
    graph[i].sort()

# ----------------------------------------
# 3. 실행
# ----------------------------------------
print("BFS 탐색 순서: ", end="")

# 주의: 함수 정의할 때 인자를 2개(graph, start_node) 받기로 했으므로
# 호출할 때도 반드시 2개를 넘겨줘야 함!
bfs(graph, 1)

```

---

## 4. 실행 과정 추적 (Trace)

> **DFS와 동일한 예시:** `1-2, 1-3, 2-4, 2-5, 4-6, 5-6, 6-7, 3-7`

**[실제 탐색 순서: 1 → 2 → 3 → 4 → 5 → 7 → 6]**

1. **`bfs(1)` 시작:** 큐 `[1]`, 방문 `[1]`
2. **1 추출:** 1의 이웃 `[2, 3]`을 큐에 넣음. 큐 `[2, 3]`, 방문 `[1, 2, 3]`
3. **2 추출:** 2의 이웃 중 안 간 곳 `[4, 5]`를 큐에 넣음. 큐 `[3, 4, 5]`, 방문 `[1, 2, 3, 4, 5]`
4. **3 추출:** 3의 이웃 중 안 간 곳 `[7]`을 큐에 넣음. 큐 `[4, 5, 7]`, 방문 `[1, 2, 3, 4, 5, 7]`
5. **4 추출:** 4의 이웃 중 안 간 곳 `[6]`을 큐에 넣음. 큐 `[5, 7, 6]`, 방문 `[1, 2, 3, 4, 5, 7, 6]`
6. **5 추출:** 5의 이웃 `[2, 6]`은 이미 방문함. 패스. 큐 `[7, 6]`
7. **7 추출:** 7의 이웃 `[6, 3]`은 이미 방문함. 패스. 큐 `[6]`
8. **6 추출:** 6의 이웃 모두 방문함. 큐 `[]` 종료.

**결과:** 1에서 같은 거리에 있는 노드들을 층(Level)별로 훑으며 나갑니다.

---

## 5. 배운 점 & 주의할 점 (Retrospective)

1. **방문 체크의 타이밍:** BFS는 큐에서 **꺼낼 때가 아니라 넣을 때** 방문 체크를 해야 합니다. 그렇지 않으면 동일한 노드가 여러 번 큐에 중복해서 들어가는 대참사(메모리 초과)가 발생할 수 있어요.
2. **`deque` 사용 권장:** 파이썬의 일반 리스트로 `pop(0)`을 하면 시간 복잡도가 $O(N)$이지만, `collections.deque`의 `popleft()`는 $O(1)$입니다. 속도 차이가 엄청나요!
3. **최단 경로 보장:** BFS는 가중치가 없는 그래프에서 시작점에서 도착점까지의 "최소 간선 수"를 보장합니다. DFS는 단순히 "길이 있다"는 것만 알 수 있는 것과 대조적이죠.
4. **메모리 사용량:** DFS는 재귀 깊이가 깊어지면 위험하지만, BFS는 한 번에 큐에 담기는 노드가 많아질 경우 메모리를 많이 차지할 수 있습니다.
