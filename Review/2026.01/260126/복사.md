
# 📝 파이썬의 객체 복사 (Copy)

단순히 값을 복사하는 것처럼 보여도, 내부적으로는 참조(주소)가 복사되는 경우가 많아 주의가 필요하다.

## 1. 객체와 참조 (Object & Reference)

파이썬의 변수는 값을 직접 저장하는 상자가 아니라, **객체의 메모리 주소를 가리키는 이름표(Label)**이다.

### ① 가변 vs 불변 (Mutable vs Immutable)

데이터의 값이 변할 수 있는지에 따라 메모리 관리 방식이 다르다.

* **Mutable (가변 객체)**: 생성 후 내용을 변경할 수 있다.
* 종류: `list`, `dict`, `set`
* 특징: 값을 바꾸면 메모리 주소는 그대로 유지된 채 값만 바뀐다.


* **Immutable (불변 객체)**: 생성 후 내용을 변경할 수 없다.
* 종류: `int`, `float`, `str`, `tuple`
* 특징: 값을 바꾸려고 하면, 아예 **새로운 객체**를 생성하여 변수가 그곳을 가리키게 한다.



### ② 할당 연산자 (`=`)의 의미

`=`은 복사가 아니다. 단순히 **같은 객체에 이름표를 하나 더 붙이는 것(참조 복사)**이다.

```python
a = [1, 2, 3]
b = a  # b는 a와 같은 주소를 바라본다.

b[0] = 100
print(a) # [100, 2, 3] -> b를 바꿨는데 a도 바뀜 (같은 놈이니까!)

```

---

## 2. 얕은 복사 (Shallow Copy)

객체의 껍데기 **(최상위 요소)** 만 새로운 메모리에 복사한다.
하지만 내부에 들어있는 **하위 객체(리스트 안의 리스트 등)는 여전히 원본의 참조를 공유**한다.

### ① 사용 방법

1. **슬라이싱**: `list[:]`
2. **메서드**: `list.copy()`
3. **함수**: `list(original)`

```python
a = [1, 2, 3]
b = a[:] # 새로운 껍데기를 만듦

b[0] = 999
print(a) # [1, 2, 3] -> 원본 안전함 (1차원일 때)

```

### ⚠️ 치명적 한계 (중첩 리스트) ★★★

리스트 안에 리스트가 있는 경우(다차원), 겉은 분리되었지만 **속(내부 리스트)은 여전히 공유**된다.

```python
a = [1, 2, [3, 4]]
b = a[:] 

b[2][0] = 999 # 내부 리스트를 수정
print(a) # [1, 2, [999, 4]] -> 원본이 훼손됨!

```

---

## 3. 깊은 복사 (Deep Copy)

객체의 껍데기뿐만 아니라, 그 안에 들어있는 **모든 하위 요소까지 재귀적으로 새롭게 복사**한다.
원본과 복사본이 완벽하게 독립적인 남남이 된다.

### 사용 방법

파이썬 내장 모듈인 **`copy`를 `import`하여 사용**한다.

```python
import copy

original = [1, 2, [3, 4]]
deep_copied = copy.deepcopy(original)

deep_copied[2][0] = 999

print(original)    # [1, 2, [3, 4]] -> 원본 안전함
print(deep_copied) # [1, 2, [999, 4]] -> 복사본만 변경됨

```

---

## 4. 핵심 요약 비교표

| 구분 | 할당 (`=`) | 얕은 복사 (`[:]`, copy) | 깊은 복사 (`deepcopy`) |
| --- | --- | --- | --- |
| **복사 대상** | 참조(주소)만 복사 | 겉(Shell)만 복사 | 전체(Recursive) 복사 |
| **독립성** | 완전 공유 (동일 객체) | 1차원만 독립, 내부는 공유 | **완전 독립** |
| **속도** | 매우 빠름 | 빠름 | 느림 (비용이 큼) |
| **변경 영향** | 서로 100% 영향 | 내부 객체 수정 시 영향 있음 | 서로 영향 없음 |

---

✅ **다음 단계**
객체 비교를 확실히 하기 위해 **`is` (메모리 주소 비교)와 `==` (값 비교)의 차이**를 정리해보자..
