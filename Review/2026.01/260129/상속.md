
# 📝 상속 (Inheritance)

기존 클래스(부모)의 속성과 메서드를 새로운 클래스(자식)가 물려받는 기능이다. 객체 지향 프로그래밍의 핵심이자 **코드 재사용**을 위한 가장 강력한 도구이다.

## 1. 기본 개념

* **부모 클래스 (Parent/Super/Base Class)**: 물려주는 클래스
* **자식 클래스 (Child/Sub/Derived Class)**: 물려받는 클래스

### 상속을 사용하는 이유

1. **코드 재사용**: 기존 클래스의 코드를 다시 작성하지 않고 그대로 사용할 수 있다.
2. **유지 보수**: 부모 클래스만 수정하면 모든 자식 클래스에 변경 사항이 적용된다.
3. **계층 구조**: 클래스 간의 관계를 명확히 구조화할 수 있다.

### 기본 문법

클래스 정의 시 소괄호 안에 부모 클래스 이름을 넣는다.

```python
class Parent:
    def __init__(self):
        self.value = "부모"

    def show(self):
        print(f"나는 {self.value}입니다.")

class Child(Parent): # Parent를 상속받음
    pass

c = Child()
c.show() # 나는 부모입니다. (부모의 메서드를 그대로 사용)

```

---

## 2. super() 함수

자식 클래스에서 **부모 클래스의 메서드(특히 `__init__`)를 호출**할 때 사용한다.

* 자식 클래스에서 독자적인 초기화(`__init__`)를 하면서도, 부모의 필수 초기화 로직을 유지하고 싶을 때 필수적이다.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Student(Person):
    def __init__(self, name, age, student_id):
        # 부모의 __init__을 호출하여 이름과 나이 설정을 위임함
        super().__init__(name, age) 
        self.student_id = student_id # 학생만의 고유 속성

s = Student('Alice', 20, 'S1234')
print(s.name)       # Alice (부모가 처리)
print(s.student_id) # S1234 (자식이 처리)

```

> **Tip**: `super()`를 사용할 때는 `self` 인자를 넘기지 않는다.

---

## 3. 메서드 오버라이딩 (Method Overriding)

부모 클래스에 이미 정의된 메서드를 **자식 클래스에서 같은 이름으로 다시 정의(덮어쓰기)**하는 것이다.

* 부모의 기능을 무시하고 자식에게 맞는 새로운 동작을 정의할 때 사용한다.

```python
class Person:
    def greeting(self):
        print("안녕하세요.")

class Student(Person):
    # 부모의 greeting을 덮어씌움 (재정의)
    def greeting(self):
        print("안녕하세요. 저는 학생입니다.")

p = Person()
p.greeting() # 안녕하세요.

s = Student()
s.greeting() # 안녕하세요. 저는 학생입니다. (자식의 메서드가 우선됨)

```

---

## 4. 다중 상속 (Multiple Inheritance)

두 개 이상의 부모 클래스로부터 상속을 받는 기능이다.

* 파이썬은 다중 상속을 지원하지만, 복잡성을 증가시키므로 주의해서 사용해야 한다.

```python
class Person:
    def greeting(self):
        print("안녕하세요.")

class Mom(Person):
    def gene(self):
        print("엄마의 유전자")

class Dad(Person):
    def gene(self):
        print("아빠의 유전자")

class Child(Mom, Dad): # 엄마와 아빠 모두에게 상속받음
    pass

c = Child()
c.greeting() # 안녕하세요.
c.gene()     # 엄마의 유전자 (순서상 Mom이 앞에 있어서)

```

### 💎 다이아몬드 문제와 MRO

다중 상속 시, 여러 부모가 같은 이름의 메서드를 가질 경우 **누구의 메서드를 먼저 실행할지** 결정해야 한다. 이를 해결하는 규칙이 **MRO (Method Resolution Order)**이다.

* **`ClassName.mro()`** 또는 **`ClassName.__mro__`**로 확인 가능하다.
* 탐색 순서: **자식(나) → 부모1(왼쪽) → 부모2(오른쪽) → ... → 최상위(object)**

```python
print(Child.mro())
# [<class '__main__.Child'>, <class '__main__.Mom'>, <class '__main__.Dad'>, <class '__main__.Person'>, <class 'object'>]

```

---

✅ **다음 단계**
상속의 개념을 익혔다면, 객체 지향의 또 다른 핵심인 **캡슐화(Encapsulation)**와 접근 제어자(`public`, `protected`, `private`)의 개념, 그리고 파이썬에서의 `__변수명` 처리(Name Mangling)에 대해 알아보자.