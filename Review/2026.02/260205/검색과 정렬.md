
# 📝 검색과 정렬 (Search & Sort)

원하는 데이터를 찾아내고, 데이터를 순서대로 나열하는 핵심 알고리즘이다.

## 1. 순차 검색 (Sequential Search)

일렬로 되어 있는 자료를 순서대로 검색하는 가장 직관적인 방법이다.

* **특징**: 구현이 쉽지만, 검색 대상이 많으면 비효율적이다.
* **시간 복잡도**:  (최악의 경우 끝까지 다 봐야 함)

### ① 정렬되어 있지 않은 경우

* 첫 번째 원소부터 하나씩 비교한다.
* 찾는 키와 일치하면 그 인덱스를 반환한다.
* 끝까지 갔는데 없으면 검색 실패.

### ② 정렬되어 있는 경우

* 오름차순으로 정렬되어 있다면, 검색하다가 **키 값보다 큰 원소를 만나는 순간** 검색을 중단할 수 있다. (뒤에는 더 큰 값만 있을 테니까)

---

## 2. 이진 검색 (Binary Search) ★★★★★

자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법이다.

* **필수 조건: 자료가 반드시 정렬(Sorted)되어 있어야 한다.**
* **시간 복잡도**:  (한 번 비교할 때마다 검색 범위가 반으로 줄어든다.)

### 검색 과정

1. 검색 범위의 **시작점(`start`)**과 **종료점(`end`)**을 정한다.
2. **중앙값(`middle`)**을 구한다.
3. 중앙값과 찾는 값(`key`)을 비교한다.
* `key == middle`: 검색 성공!
* `key < middle`: 찾는 값이 왼쪽 구간에 있다.  `end = middle - 1`
* `key > middle`: 찾는 값이 오른쪽 구간에 있다.  `start = middle + 1`


4. `start <= end`일 동안 반복한다.

### 💻 코드 (반복문 구조)

```python
def binary_search(arr, key):
    start = 0
    end = len(arr) - 1
    
    while start <= end:
        middle = (start + end) // 2 # 중앙 인덱스
        
        if arr[middle] == key: # 찾았다!
            return True # 또는 middle(인덱스) 반환
        elif arr[middle] > key: # 왼쪽 구역 탐색
            end = middle - 1
        else: # arr[middle] < key -> 오른쪽 구역 탐색
            start = middle + 1
            
    return False # 못 찾음

```

---

## 3. 선택 정렬 (Selection Sort)

주어진 자료 중 **가장 작은 값의 원소부터 차례대로 선택**하여 위치를 교환하는 방식이다.

### 특징

* **시간 복잡도**:  (이중 루프)
* **비교**: 버블 정렬과 시간 복잡도는 같지만, **교환 횟수가 훨씬 적다.** (한 번의 패스에서 딱 한 번만 교환)

### 정렬 과정

1. 주어진 리스트 구간 중에서 **최솟값**을 찾는다.
2. 그 최솟값을 리스트의 **맨 앞 값**과 교환(Swap)한다.
3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위 과정을 반복한다.

### 💻 코드

```python
def selection_sort(arr):
    N = len(arr)
    
    for i in range(N - 1): # 맨 마지막 요소는 자연스럽게 정렬되므로 N-1까지
        min_idx = i # 일단 기준 위치를 최솟값이라 가정
        
        # i+1부터 끝까지 훑으면서 진짜 최솟값 위치 찾기
        for j in range(i + 1, N):
            if arr[min_idx] > arr[j]:
                min_idx = j
                
        # 기준 위치(i)와 최솟값 위치(min_idx) 교환
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        
    return arr

data = [64, 25, 12, 22, 11]
print(selection_sort(data)) # [11, 12, 22, 25, 64]

```

---

## 4. 셀렉션 알고리즘 (Selection Algorithm)

자료에서 **k번째로 큰(혹은 작은) 원소**를 찾는 알고리즘이다.

* 선택 정렬을 응용한다.
* 전체를 다 정렬할 필요 없이, **k번만 선택 정렬을 수행**하면 k번째 작은 값을 알 수 있다.

```python
def select(arr, k):
    # k번째 작은 원소 찾기
    for i in range(k):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[min_idx] > arr[j]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        
    return arr[k-1] # k번째 요소 반환

```

---

✅ **다음 단계**
지금까지 리스트(List) 기반의 알고리즘을 마스터했다. 이제 데이터를 저장하는 또 다른 형태인 **문자열(String) 처리**로 넘어가서, 문자열을 뒤집거나 비교하고, 패턴을 찾는(KMP, 보이어-무어) 알고리즘에 대해 정리해 보자.