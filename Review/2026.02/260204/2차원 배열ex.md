
# 📝 실전 문제로 보는 2차원 배열 & 델타 탐색

## 1. 델타 탐색 활용: 이웃한 원소의 차이 합

2차원 배열 탐색의 가장 기본이 되는 문제 패턴이다. 상하좌우를 살펴야 한다.

### ❓ 문제

 2차원 배열이 주어진다. 각 칸의 요소에 대해서, 그 요소와 **상하좌우에 있는 이웃한 요소와의 차이(절댓값)**를 구하고, 이 값들의 **총합**을 구하시오.
(단, 벽(범위)을 벗어나는 이웃은 계산하지 않는다.)

### 💡 풀이 접근

1. 이중 `for`문으로 모든 좌표 `(i, j)`를 순회한다.
2. 각 좌표에서 `di`, `dj`를 이용해 4방향을 탐색한다.
3. 새로운 좌표 `(ni, nj)`가 범위 내에 있는지 확인하고, 절댓값(`abs`) 차이를 누적한다.

### 💻 코드

```python
def solve_neighbor_sum(arr):
    N = len(arr) # 5
    total_sum = 0
    
    # 상, 하, 좌, 우 델타
    di = [-1, 1, 0, 0]
    dj = [0, 0, -1, 1]
    
    for i in range(N):
        for j in range(N):
            # 현재 위치: arr[i][j]
            # 4방향 탐색
            for k in range(4):
                ni = i + di[k]
                nj = j + dj[k]
                
                # [핵심] 벽 넘어가면 무시 (인덱스 유효성 검사)
                if 0 <= ni < N and 0 <= nj < N:
                    diff = abs(arr[i][j] - arr[ni][nj])
                    total_sum += diff
                    
    return total_sum

# 예시 데이터 (랜덤 5x5)
data = [
    [1, 2, 3, 4, 5],
    [5, 4, 3, 2, 1],
    [1, 1, 1, 1, 1],
    [2, 2, 2, 2, 2],
    [3, 3, 3, 3, 3]
]

print(f"차이의 총합: {solve_neighbor_sum(data)}")

```

---

## 2. 배열 순회 응용: 대각선의 합 구하기

인덱스의 규칙성을 이용하는 문제이다.

### ❓ 문제

 정방형 배열에서 **좌측 상단  우측 하단 대각선**과 **우측 상단  좌측 하단 대각선** 위에 있는 요소들의 합을 구하시오. (단, 정중앙에 있는 요소가 중복될 경우 한 번만 더해야 한다.)

### 💡 풀이 접근

1. **정방향 대각선**: 행 인덱스와 열 인덱스가 같다. (`i == j`)
2. **역방향 대각선**: 행 인덱스와 열 인덱스의 합이 일정하다. (`i + j == N - 1`)
3. 이 홀수라면 정중앙(`N//2, N//2`)이 겹치므로 주의해야 한다.

### 💻 코드

```python
def diagonal_sum(arr):
    N = len(arr)
    total = 0
    
    for i in range(N):
        # 1. 정방향 대각선 (0,0), (1,1)...
        total += arr[i][i]
        
        # 2. 역방향 대각선 (0,4), (1,3)...
        # 단, 중앙 요소가 중복되지 않도록 조건 추가
        # (i != N - 1 - i)는 중앙이 아닐 때만 더하라는 뜻
        if i != N - 1 - i:
            total += arr[i][N - 1 - i]
            
    return total

arr_example = [
    [1, 0, 0, 0, 1],
    [0, 2, 0, 2, 0],
    [0, 0, 3, 0, 0],
    [0, 2, 0, 2, 0],
    [1, 0, 0, 0, 1]
]
print(f"대각선 합: {diagonal_sum(arr_example)}") # 1+1+2+2+3+2+2+1+1 = 15

```

---

## 3. 부분집합 응용: 부분집합의 합이 0이 되는 경우

비트 연산자를 활용한 부분집합 생성의 대표 예제이다.

### ❓ 문제

10개의 정수를 입력받아, 이 중 **공집합이 아닌 부분집합의 합이 0이 되는 경우**가 존재하는지 확인하시오. (True/False 출력)

### 💡 풀이 접근

1. 원소의 개수 에 대해 총 개의 부분집합이 존재한다. (`1 << N`)
2. `0`번 부분집합(공집합)을 제외하고 `1`부터 순회한다.
3. 비트 연산자 `&`를 이용해 포함된 원소를 골라내 합을 구한다.

### 💻 코드

```python
def check_zero_sum(numbers):
    N = len(numbers)
    
    # 1. 모든 부분집합 생성 (1부터 시작해서 공집합 제외)
    for i in range(1, 1 << N):
        current_sum = 0
        
        # 2. i번째 부분집합에 포함된 원소 확인
        for j in range(N):
            if i & (1 << j): # j번째 비트가 1이라면
                current_sum += numbers[j]
        
        # 3. 합 검사
        if current_sum == 0:
            return True # 0이 되는 경우 발견!
            
    return False # 끝까지 못 찾음

data = [-7, -3, -2, 5, 8] 
# 부분집합 {-3, -2, 5}의 합이 0이 됨
print(f"합이 0인 부분집합 존재? {check_zero_sum(data)}") # True

```

---

✅ **다음 단계**
2차원 배열과 완전 검색까지 정리가 끝났습니다. 이제 알고리즘의 효율성을 비약적으로 높여주는 **검색(Search)** 파트로 넘어가서 **이진 검색(Binary Search)**과 **선택 정렬(Selection Sort)**에 대해 정리해 보자.