
# 📝 2차원 리스트 (2D List)

1차원 리스트를 요소로 가지는 리스트이다. 행(Row)과 열(Column)로 구성된 테이블 형태의 데이터를 다루기에 적합하다.
이 내용은 코딩 테스트의 **구현(Implementation) 및 시뮬레이션** 문제에서 가장 많이 쓰이는 기초 체력이다.

## 1. 구조 및 초기화

파이썬에서는 리스트 안에 리스트를 넣어 2차원 배열을 구현한다.

### ① 선언 방식 (주의사항)

2차원 배열을 만들 때 **얕은 복사(Shallow Copy)** 문제를 피하기 위해 반드시 **리스트 컴프리헨션**을 사용해야 한다.

```python
N = 3 # 행 (세로)
M = 4 # 열 (가로)

# [Good] 올바른 초기화 (각 행이 독립적)
arr = [[0] * M for _ in range(N)]
arr[0][0] = 1 
# 결과: [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]

# [Bad] 잘못된 초기화 (참조 복사)
arr_bad = [[0] * M] * N
arr_bad[0][0] = 1
# 결과: [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]] -> 모든 행이 같이 바뀜!

```

---

## 2. 배열 순회 (Array Traversal)

2차원 배열의 모든 원소를 빠짐없이 조사하는 방법이다.

### ① 행 우선 순회 (Row-major)

가장 기본적이다. `i`(행)를 고정하고 `j`(열)를 움직인다.

```python
# i: 행의 좌표, j: 열의 좌표
for i in range(N):
    for j in range(M):
        print(arr[i][j])

```

### ② 열 우선 순회 (Column-major)

세로로 읽는다. `j`(열)를 고정하고 `i`(행)를 움직인다.

```python
for j in range(M):
    for i in range(N):
        print(arr[i][j])

```

### ③ 지그재그 순회 (Zig-zag)

첫 줄은 오른쪽으로, 다음 줄은 왼쪽으로 읽는다.

```python
for i in range(N):
    for j in range(M):
        # i가 짝수면 j 그대로 (0 -> M-1)
        # i가 홀수면 역순 (M-1 -> 0)
        col = j if i % 2 == 0 else M - 1 - j
        print(arr[i][col])

```

---

## 3. 델타 탐색 (Delta Search) ★★★★★

2차원 배열의 특정 좌표 `(r, c)`에서 **상하좌우(4방향) 인접한 요소**를 탐색할 때 사용하는 필수 기법이다.

### 핵심 로직

1. 이동할 방향(상하좌우)에 따른 좌표 변화량(`di`, `dj`)을 리스트로 정의한다.
2. 반복문을 통해 4방향을 모두 확인한다.
3. **반드시 범위 체크(`0 <= ni < N`)를 해야 한다.**

```python
# 상, 하, 좌, 우
di = [-1, 1, 0, 0] # 행 이동 (위로 가면 행 번호 감소)
dj = [0, 0, -1, 1] # 열 이동

N = 5
arr = [[0]*N for _ in range(N)]

for i in range(N):      # 모든 칸에 대해서
    for j in range(N):
        
        # 4방향 탐색
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            
            # [중요] 인덱스가 배열 범위를 벗어나지 않는지 확인
            if 0 <= ni < N and 0 <= nj < N:
                print(arr[ni][nj])

```

---

## 4. 전치 행렬 (Transpose)

대각선을 축으로 행과 열을 맞바꾸는 것이다. `(i, j)` 위치를 `(j, i)`로 옮긴다.

```python
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# 1. 반복문 이용 (정사각형 행렬일 때)
for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]

# 2. zip 함수 이용 (가장 파이썬다운 방식)
transposed = list(zip(*arr))
# 결과: [(1, 4, 7), (2, 5, 8), (3, 6, 9)]

```

---

## 5. 부분집합 (Subset) - 비트 연산 활용

어떤 집합의 원소들로 만들 수 있는 모든 부분적인 집합을 구한다.

* 원소 개수가 일 때 부분집합의 총개수는 이다.
* **비트 마스킹(Bitmasking)**을 이용하면 간결하게 구현할 수 있다.

### 비트 연산자 이해

* `1 << n`:  (부분집합의 총개수)
* `i & (1 << j)`: `i`의 `j`번째 비트가 1인지 확인 (j번째 원소가 포함되었는지 검사)

```python
arr = ['A', 'B', 'C']
n = len(arr) # 3

# 0부터 2^n - 1 까지 반복 (0 ~ 7)
for i in range(1 << n):
    subset = []
    for j in range(n):
        # i의 j번째 비트가 1이면 j번째 원소를 부분집합에 포함
        if i & (1 << j):
            subset.append(arr[j])
    print(subset)

```

---

✅ **다음 단계**
2차원 배열의 탐색을 익혔으니, 이를 활용하여 **이진 검색(Binary Search)**으로 데이터를 빠르게 찾는 방법과, 배열 정렬의 또 다른 방법인 **선택 정렬(Selection Sort)**에 대해 정리해 보자.