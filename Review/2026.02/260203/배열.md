
# 📝 배열 (Array)과 리스트

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조이다.

## 1. 배열의 필요성

* 여러 개의 변수를 각각 선언하는 것은 비효율적이다.
* 다수의 데이터를 저장하고 효율적으로 접근(인덱스 사용)하기 위해 사용한다.
* 파이썬에서는 **리스트(List)**를 사용하여 배열을 구현한다.

---

## 2. 1차원 배열

* 별도의 문법 없이 `[num1, num2, ...]` 형태로 선언한다.
* **인덱스**를 통해 `Arr[0]`, `Arr[1]` 등으로 접근한다.

### 대표적인 정렬 알고리즘 (기초)

* **버블 정렬 (Bubble Sort)**: 인접한 두 원소를 비교하여 자리를 교환하는 방식. (`O(n^2)`)
* **카운팅 정렬 (Counting Sort)**: 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 방식. (`O(n+k)`)

---

## 3. 2차원 배열 (2D Array)

1차원 리스트를 요소로 가지는 리스트이다. (리스트 안의 리스트)

### ① 선언 주의사항

2차원 배열을 초기화할 때 **얕은 복사** 문제를 피하기 위해 **리스트 컴프리헨션**을 사용하는 것이 좋다.

```python
N = 3 # 행의 개수
M = 4 # 열의 개수

# [나쁜 예] 얕은 복사로 인해 모든 행이 같은 객체를 참조함
arr = [[0] * M] * N 
arr[0][0] = 1 
# 결과: [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]] (모든 행이 바뀜)

# [좋은 예] 리스트 컴프리헨션 사용 (각 행이 독립적)
arr = [[0] * M for _ in range(N)]

```

### ② 배열 순회 (Traversal) ★★★

2차원 배열의 모든 원소를 빠짐없이 조사하는 방법이다. `i`는 행(Row), `j`는 열(Column)을 의미한다.

**1. 행 우선 순회 (Row-major)**
가로로 한 줄씩 읽는 가장 기본적인 방법이다.

```python
# N x M 배열
for i in range(N):      # 행
    for j in range(M):  # 열
        print(arr[i][j])

```

**2. 열 우선 순회 (Column-major)**
세로로 한 줄씩 읽는 방법이다.

```python
for j in range(M):      # 열
    for i in range(N):  # 행
        print(arr[i][j])

```

**3. 지그재그 순회 (Zig-zag)**
첫 줄은 오른쪽으로, 다음 줄은 왼쪽으로 읽는 방식이다.

```python
for i in range(N):
    for j in range(M):
        # i가 짝수면 j 그대로(0->M), 홀수면 역순(M-1->0)
        col = j if i % 2 == 0 else M - 1 - j
        print(arr[i][col])

```

---

## 4. 델타 탐색 (Delta Search) ★★★★★

2차원 배열의 특정 좌표 `(r, c)`에서 **상하좌우(4방향) 인접한 요소**를 탐색할 때 사용한다.
미로 찾기나 그래프 탐색 문제의 기본이 된다.

### 구현 방법

방향별 인덱스 증감량을 리스트(`di`, `dj` 또는 `dr`, `dc`)로 정의하여 사용한다.

```python
# 상, 하, 좌, 우
di = [-1, 1, 0, 0] # 행 이동량 (위로 갈 땐 행 인덱스가 감소)
dj = [0, 0, -1, 1] # 열 이동량

N = 5 # 배열 크기
arr = [[0]*N for _ in range(N)]

for i in range(N):
    for j in range(N):
        # 현재 위치 (i, j)에서 4방향 탐색
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            
            # [중요] 유효한 인덱스인지 확인 (범위 체크)
            if 0 <= ni < N and 0 <= nj < N:
                print(arr[ni][nj])

```

---

## 5. 전치 행렬 (Transpose)

대각선을 기준으로 행과 열을 맞바꾸는 것이다. (`(i, j)` 위치를 `(j, i)`로 이동)

### 구현 방법

1. **반복문 사용**: `if i < j` 조건 등을 활용해 교환
2. **`zip` 함수 활용 (파이썬)**:

```python
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# zip을 이용한 전치 (튜플로 반환됨)
transposed = list(zip(*arr))
print(transposed) 
# [(1, 4, 7), (2, 5, 8), (3, 6, 9)]

```

---

## 6. 부분집합 (Subset)

집합의 원소들로 만들 수 있는 모든 부분적인 집합을 의미한다.

* 원소의 개수가 N개일 때, 부분집합의 개수는 **2^N**개이다.
* **비트 연산자**를 활용하여 간결하게 생성할 수 있다.

```python
arr = [1, 2, 3]
n = len(arr)

for i in range(1 << n):     # 1 << n : 2^n (부분집합의 개수만큼 반복)
    subset = []
    for j in range(n):      # 원소의 수만큼 비트 비교
        if i & (1 << j):    # i의 j번째 비트가 1이면 포함
            subset.append(arr[j])
    print(subset)

```

---

✅ **다음 단계**
2차원 배열과 델타 탐색을 이해했다면, 이를 응용한 **이진 검색(Binary Search)**과 **선택 정렬(Selection Sort)**의 개념을 정리해 보자. 이는 알고리즘 효율성을 높이는 중요한 단계이다.