
# 📝 [TIL] 02.06 알고리즘 - 문자열 (String)

> **"문자열은 결국 문자의 배열이다."**

## 1. 컴퓨터에서의 문자 표현 (ASCII & Unicode)

컴퓨터는 모든 데이터를 0과 1로 저장한다. 문자도 예외가 아니며, 각 문자에 대응되는 숫자를 정해놓고 사용한다.

### 🔹 필수 암기 (ASCII Code)

알고리즘 문제에서 `ord()` 함수를 쓸 때 기준점을 잡기 위해 외워둬야 한다.

* **`'0'` (문자 0)**: 48
* **`'A'` (대문자 A)**: 65
* **`'a'` (소문자 a)**: 97
* 대문자와 소문자의 차이는 `32`이다.



### 🔹 파이썬 변환 함수

* `ord('A')`  `65` (문자  정수)
* `chr(65)`  `'A'` (정수  문자)

---

## 2. 파이썬 문자열의 특징 (Immutable)

C언어나 Java와 달리, 파이썬의 문자열은 **불변(Immutable)**이다.

* **특징**: `s[0] = 'a'` 처럼 인덱스로 직접 값을 바꿀 수 없다. (에러 발생)
* **해결법**:
1. 새로운 문자열을 생성한다. (`s = 'a' + s[1:]`)
2. **리스트로 변환**하여 수정한 뒤 다시 합친다. (가장 많이 씀)


```python
s = "Hello"
arr = list(s)  # ['H', 'e', 'l', 'l', 'o']
arr[0] = 'h'
s = "".join(arr) # "hello"

```



---

## 3. 핵심 문자열 알고리즘 (구현력)

### ① 문자열 뒤집기 (Reverse)

* **Pythonic**: `s = s[::-1]` (슬라이싱 활용, 가장 빠름)
* **알고리즘적 접근**: `Two Pointer` 활용 (양 끝에서 교환)
```python
# 리스트로 변환 후 교환
def my_reverse(s_list):
    left, right = 0, len(s_list) - 1
    while left < right:
        s_list[left], s_list[right] = s_list[right], s_list[left]
        left += 1
        right -= 1
    return "".join(s_list)

```



### ② 문자열 숫자로 변환 (atoi / itoa)

`int()`, `str()` 함수 없이 직접 구현하는 로직. (가끔 면접이나 기초 문제로 나옴)

* **String to Integer (atoi)**:
```python
def my_atoi(s):
    value = 0
    for char in s:
        # 기존 값에 10을 곱하고 1의 자리를 더함
        digit = ord(char) - ord('0')
        value = value * 10 + digit
    return value

```


* **Integer to String (itoa)**: 숫자를 10으로 나누며 나머지를 문자로 변환하여 쌓음.

---

## 4. 패턴 매칭 (Pattern Matching) ★ 중요

긴 글(`T`) 안에서 특정 단어(`P`)를 찾는 방법.

### ① 고지식한 알고리즘 (Brute Force)

IM 시험에서는 이 방법만 알아도 충분하다.

* **시간 복잡도**:  (M:패턴길이, N:본문길이)
* **로직**: 본문의 처음부터 끝까지 돌면서, 패턴과 일치하는지 하나씩 비교한다. 틀리면 **본문 인덱스를 한 칸만 뒤로** 이동해서 다시 시작한다.

```python
def brute_force(p, t):
    N = len(t) # 전체 텍스트
    M = len(p) # 찾을 패턴
    
    for i in range(N - M + 1): # 시작점 순회
        # 패턴 길이만큼 비교
        found = True
        for j in range(M):
            if t[i + j] != p[j]:
                found = False
                break
        if found:
            return i # 찾은 위치 반환
            
    return -1 # 못 찾음

```

### ② KMP / 보이어-무어 (Boyer-Moore)

* **KMP**: 불일치가 발생했을 때, 접두사/접미사 일치 정보를 이용해 점프한다.
* **보이어-무어**: 패턴의 **오른쪽 끝**부터 비교한다. 불일치 시 문자를 보고 스킵 테이블(Skip Table)을 이용해 많이 건너뛴다. (상용 에디터의 '찾기' 기능에서 주로 사용)
* *Tip: A형/코테에서는 파이썬 내장 함수 `find()`나 `in` 연산자를 쓰면 내부적으로 최적화되어 있어 빠르다.*

---

## 5. 실전 백준 추천 문제 (문자열)

오늘 배운 내용을 바로 적용해볼 수 있는 문제들입니다.

1. **[Bronze 2] 1152번: 단어의 개수** (기초 파싱)
2. **[Bronze 2] 2675번: 문자열 반복** (구현)
3. **[Bronze 1] 1157번: 단어 공부** (DAT/카운팅 활용)
4. **[Bronze 2] 2908번: 상수** (뒤집기, `atoi`)
5. **[Silver 5] 1316번: 그룹 단어 체커** (구현력)

> **💡 오늘의 결론**
> 파이썬은 문자열 처리가 매우 강력하다 (`split`, `join`, `find`, 슬라이싱).
> 하지만 **IM/A형을 위해서는 라이브러리 없이 인덱스로 접근하여 비교/탐색하는 로직**을 반드시 손으로 짤 수 있어야 한다.